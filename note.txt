vue create yfnews-m 创建项目
选择项目需要的条件
github创建空仓库
本地git init
把.ssh文件放在项目根目录下面（方便HBuild X 提交代码）
在.gitignore中添加.ssh
git add .
git commit -m "first commit"
git remote add origin git@github.com:GeorgeFY/yfnews-m.git
git push -u origin master
把项目提交到github的远程仓库

项目导入到HBuild X
新建 note.txt文件
测试HBuild X提交代码

创建分支，后续代码提交到分支 不随便改动分支
git checkout -b dev
git push -u origin dev 代码push到开发分支

调试初始化目录结构
1：删除初始化的默认文件
2：新增调整我们需要的目录结构
api目录 utils目录 styles目录
在styles目录新建index.less文件 作为全局样式
需要在main.js中引入import './styles/index.less'



导入vant库之前先需要确认vue版本是（vue版本和vue/cli版本有区别）
vue版本 可以在package.json中查看 或者cnpm list vue中查看
vue/cli版本 可以用vue -V查看
因为我们使用的vue版本是vue@2.6.12  所以
# Vue 2 项目，安装 Vant 2.x 版本：
npm i vant -S

为了后续方便，没有使用按需导入，是直接全部导入进来 在main.js中，这样以后可以直接使用vant所有组件
导入Vant组件库
cnpm i vant -S

import Vue from 'vue';
import Vant from 'vant';
import 'vant/lib/index.css';

Vue.use(Vant);


rem适配
vant推荐两个插件  postcss-pxtorem       lib-flexible
具体参考vant官方文档 进阶使用中rem适配
package.json文件里面browserslist和postcss.config.js里面的
autoprefixer: {
      browsers: ['Android >= 4.0', 'iOS >= 8']
    }
冲突，导致编译启动项目爆警告。
解决办法，把package.json文件里面browserslist注释掉
只考虑移动端Android >= 4.0', 'iOS >= 8'
在postcss.config.js文件里面去掉autoprefixer: {
      browsers: ['Android >= 4.0', 'iOS >= 8']
    }
	
字体图标导入
在iconfont里面新建项目后，把svg图片导入。
Font class里面在线预览，生成代码。负载代码在styles文件夹下新建icon.less文件
把生成的代码放在里面。然后把icon.less在index.less里面导入让全局可用  @import "./icon.less";


配置路由页面
1：登入页面
views下面新建login文件夹，下面新建index.vue
基本格式，name为LoginIndex
路由懒加载
 {
    path: '/login',
    name: 'login',
    component: () => import('@/views/login')
  }
  
2：配置底部导航栏页面
	1：先views下面新建layout文件夹，里面放index.vue作为底部导航栏页面。
		里面放van-tabbar 以及需要子路由出口
		才有vant格式 路由模式van-tabbar标签后面跟router
		子元素用to属性来去匹配页面路径
		参照vant官方文档，active双向绑定。实现点击切换颜色
	2：在router文件夹下面的index.js里面配置路由。采用路由懒加载方式
	{
    path: '/',
    name: 'layout',
    component: () => import('@/views/layout/'),
	}
3：子路由页面新建与配置
	根据layout里面tabbar选项来新建相应的子页面（home,qa,video,my）
	全部都是在views文件夹下面新建对应文件夹，里面新建Index.vue文件
	
	创建好后，配置二级路由（layout）
	children: [
      {
        path: '', // 默认子路由
        name: 'home',
        component: () => import('@/views/home/')
      },
      {
        path: '/qa',
        name: 'qa',
        component: () => import('@/views/qa/')
      },
      {
        path: '/video',
        name: 'video',
        component: () => import('@/views/video/')
      },
      {
        path: '/my',
        name: 'my',
        component: () => import('@/views/my/')
      }
    ]
	默认子路由不给路径，让开始就指向这个页面
	
封装请求模块
utils文件夹下面新建request.json
 引入axios,新建axios.导出request
 const request = axios.create({
  baseURL: 'http://ttapi.research.itcast.cn/' // 基础路径
})
export default request
 
 登入页面布局
	ps使用不熟练，改用蓝湖操作
	在ps中打开设计稿，选用蓝湖插件上传设计稿，在网页端查看。所以像素的除以2位实际值
	页面布局，配合蓝湖， 效果图，实际图一起来操作。主要是用到vant组件后，组件里面的内容需要获取类名字
	
	头部样式在多个页面都会用到，直接把样式写到index.less中，取名app-nav-bar，在用到这个样式的时候，给类名它
	Button里面放字体图标icon-prefix 
	如果修改样式后不生效，可能是选择类名后级别不够可以在样式后面加  !important
	另外一种方法，全局样式覆盖vant的样式，可以在main.js中最后倒入全局样式，让vant样式在前面，全局样式在后面
	
登入页面 功能基本实现
	给登录按钮注册点击事件。
	  // 1:找到数据接口(接口文档)
      // 2:封装请求方法
      // 3:请求调用登入
	  // 4:处理响应结果
	 
	 创建 src/api/user.js 模块，封装登录请求方法：
	 /**
 * 用户相关的请求模块
 */
import request from "@/utils/request"

/**
 * 用户登录
 */
export const login = data => {
  return request({
    method: 'POST',
    url: '/app/v1_0/authorizations',
    data
  })
}
登录处理函数如下

默认号码：
17090086870
246810
import { login } from '@/api/user'

async onLogin () {
  try {
    const res = await login(this.user)
    console.log('登录成功', res)
  } catch (err) {
    if (err.response.status === 400) {
      console.log('登录失败', err)
    }
  }
}
表单中数据双向绑定v-model this.user可以获取到数据，作为参数传递到登入请求中
使用async await  promise的语法糖处理，省去回调函数

登入提示效果（Toast）
需要单独加载import { Toast } from 'vant'
duration: 0  参数为0表示一直不消失
如果不import Toast  可以使用this.$toast

表单提交效果实现
使用 Field 的 rules 属性定义校验规则。
最好不要写在模板中，在data中定义一个属性formRules
	1：发送验证码，登入都是button点击都会导致submit提交  怎么处理
	2：提示消息都是标红在input下面输出  如何改为toast
	
	form表单 show-error show-error-message都设置为false，增加failed事件，van-field添加name属性
	在failed事件中输出错误信息，并且把它位置放在上面
	onFailed (error) {
      if (error.errors[0]) {
        Toast({
          message: error.errors[0].message,
          position: 'top'
        })
      }
    }
	
验证码点击实现倒计时功能
	校验手机号码	验证通过-》发送请求-》用户接受验证码-》请求登入
	请求发送验证码-》隐藏发送按钮，显示倒计时按钮
	倒计时结束，隐藏倒计时，显示发送按钮
	
	验证表单（vaildate）支持name来验证表单，返回一个promise对象，直接使用async await
	点击发送验证码时候click加一个prevent阻止默认验证事件
		prevent为vue中事件修饰符
	通过 ref 可以获取到 Form 实例并调用实例方法
	在from中ref="login-from"
	async onSengSms () {
      try {
        await this.$refs['login-from'].validate('mobile')
      } catch (err) {
        // TODO handle the exception
        Toast({
          message: err.message,
          position: 'top'
        })
      }
    }
	
短信发送请求
export const sendSms = mobile => {
  return request({
    method: 'GET',
    url: `/app/v1_0/sms/codes/${mobile}`
  })
}  
es6拼接
eg:
http://ttapi.research.itcast.cn/app/v1_0/sms/codes/18271671850
{
    "message": "OK",
    "data": {
        "mobile": "18271671850"
    }
}

发送短信代码
const res = await sendSms(this.user.mobile)
因为所有err都会到catch中，为了不同错分别提升
需要判断错误是手机号错误，还是验证码发送太频繁，或者未知错误

async onSengSms () {
      try {
        await this.$refs['login-from'].validate('mobile')
        const res = await sendSms(this.user.mobile)
        console.log(res)
      } catch (err) {
        // TODO handle the exception
        let message = ''
        if (err && err.response && err.response.status === 429) {
          message = '发送太频繁,请稍后在发送'
        } else if (err.name === 'mobile') {
          message = err.message
        } else {
          // 未知错误
          message = '发送失败!请重试'
        }
        Toast({
          message,
          position: 'top'
        })
      }
    }
	
	倒计时
	<van-count-down v-if="isCountDownShow"
        :time="1000 * 6"
        format="ss s"
        @finish="isCountDownShow = false"/>
		组件  v-if v-else显示   finish事件倒计时结束触发
		
		
	发送请求时候，需要页面按钮禁用，不要重复触发事件发请求
	增加loading,默认为false,点击发送验证码按钮后为true，请求结束该为false.不管请求是否成功
	
	
	本地存储的数据不是响应式的，用户存储 Token  Vuex容器（获取方便，响应式）
	对象不能直接存在本地存储，需要JSON.stringify转成字符串在存储
	
	1：封装本地存储（setItem,getItem,removeItem）
	2:vueX 状态管理登入的用户
	导入setItem,getItem import { getItem, setItem } from '@/utils/storage'
	为了区别，方便阅读，设置const常量USER_KEY
	state里面先在本地存储里面读取到数据
	mutations里面设置state的值，用到函数setUser
	setUser (state, data) {
      state.user = data
    }
	在登入成功时候，使用commit调用setUser来修改state的值
	// 将后端返回的用户登录状态（token等数据）放到 Vuex 容器中
    this.$store.commit('setUser', data.data)
	
	设置成功后，放在页面刷新数据丢失，把数据存储在本地存储setItem(USER_KEY, state.user)
	
	
我的模块
	1：页面布局，配合蓝湖
	van-cell-group单元格布局(van-cell-group)
	van-cell插槽自定义布局，van-image  ,div ,van-button分别放左边图片，昵称，右侧按钮  
	
	Grid 宫格布局放数据信息（van-grid）
	van-grid-item一样使用插槽放内容（van-grid-item）
	div为solt里面放数量和名字
	
	收藏，历史使用Grid 宫格布局（设置:column-num="2"，一列放2个）
	van-cell设置页面导航<van-cell title="路由跳转" is-link to="index" />
	
	样式设置
	登入或者没有登入显示不一样的页面。v-if  v-else判断
	把vuex里面的数据通过mapState映射到页面中使用
	import { mapState } from 'vuex'
	computed: {
    ...mapState(['user'])
  }
  这样就可以在页面中使用user来获取到状态管理里面的数据
	在未登入页面，给手机图片的div给点击事件。点击跳转到login页面
	@click=$router.push('/login')

	登入界面，登入成功后，返回到之前页面。直接用this.$router.back()跳转
	
	2：实现退出功能
	使用vant组件dailog
	
	
显示当前登入用户信息
http://ttapi.research.itcast.cn/app/v1_0/user
获取用户自己信息
	1：封装请求方法getUserInfo 
		需要加header，里面放Authorization
		把store引入到api的user.js中。通过store.state.user.token获取到
		然后用es6字符串拼接
	2：create中调用loadCurrentUser,在 method中实现
		ayncs  await  把结果赋值给data中的currentUser，在页面渲染。判断数据是否合理
		
	3：通过拦截器来请求。这样做后不需要在请求中添加headers了。
		axios的拦截器方法interceptors（github中查找）
	