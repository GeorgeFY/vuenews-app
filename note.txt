vue create yfnews-m 创建项目
选择项目需要的条件
github创建空仓库
本地git init
把.ssh文件放在项目根目录下面（方便HBuild X 提交代码）
在.gitignore中添加.ssh
git add .
git commit -m "first commit"
git remote add origin git@github.com:GeorgeFY/yfnews-m.git
git push -u origin master
把项目提交到github的远程仓库

项目导入到HBuild X
新建 note.txt文件
测试HBuild X提交代码

创建分支，后续代码提交到分支 不随便改动分支
git checkout -b dev
git push -u origin dev 代码push到开发分支

调试初始化目录结构
1：删除初始化的默认文件
2：新增调整我们需要的目录结构
api目录 utils目录 styles目录
在styles目录新建index.less文件 作为全局样式
需要在main.js中引入import './styles/index.less'



导入vant库之前先需要确认vue版本是（vue版本和vue/cli版本有区别）
vue版本 可以在package.json中查看 或者cnpm list vue中查看
vue/cli版本 可以用vue -V查看
因为我们使用的vue版本是vue@2.6.12  所以
# Vue 2 项目，安装 Vant 2.x 版本：
npm i vant -S

为了后续方便，没有使用按需导入，是直接全部导入进来 在main.js中，这样以后可以直接使用vant所有组件
导入Vant组件库
cnpm i vant -S

import Vue from 'vue';
import Vant from 'vant';
import 'vant/lib/index.css';

Vue.use(Vant);


rem适配
vant推荐两个插件  postcss-pxtorem       lib-flexible
具体参考vant官方文档 进阶使用中rem适配
package.json文件里面browserslist和postcss.config.js里面的
autoprefixer: {
      browsers: ['Android >= 4.0', 'iOS >= 8']
    }
冲突，导致编译启动项目爆警告。
解决办法，把package.json文件里面browserslist注释掉
只考虑移动端Android >= 4.0', 'iOS >= 8'
在postcss.config.js文件里面去掉autoprefixer: {
      browsers: ['Android >= 4.0', 'iOS >= 8']
    }
	
字体图标导入
在iconfont里面新建项目后，把svg图片导入。
Font class里面在线预览，生成代码。负载代码在styles文件夹下新建icon.less文件
把生成的代码放在里面。然后把icon.less在index.less里面导入让全局可用  @import "./icon.less";


配置路由页面
1：登入页面
views下面新建login文件夹，下面新建index.vue
基本格式，name为LoginIndex
路由懒加载
 {
    path: '/login',
    name: 'login',
    component: () => import('@/views/login')
  }
  
2：配置底部导航栏页面
	1：先views下面新建layout文件夹，里面放index.vue作为底部导航栏页面。
		里面放van-tabbar 以及需要子路由出口
		才有vant格式 路由模式van-tabbar标签后面跟router
		子元素用to属性来去匹配页面路径
		参照vant官方文档，active双向绑定。实现点击切换颜色
	2：在router文件夹下面的index.js里面配置路由。采用路由懒加载方式
	{
    path: '/',
    name: 'layout',
    component: () => import('@/views/layout/'),
	}
3：子路由页面新建与配置
	根据layout里面tabbar选项来新建相应的子页面（home,qa,video,my）
	全部都是在views文件夹下面新建对应文件夹，里面新建Index.vue文件
	
	创建好后，配置二级路由（layout）
	children: [
      {
        path: '', // 默认子路由
        name: 'home',
        component: () => import('@/views/home/')
      },
      {
        path: '/qa',
        name: 'qa',
        component: () => import('@/views/qa/')
      },
      {
        path: '/video',
        name: 'video',
        component: () => import('@/views/video/')
      },
      {
        path: '/my',
        name: 'my',
        component: () => import('@/views/my/')
      }
    ]
	默认子路由不给路径，让开始就指向这个页面
	
封装请求模块
utils文件夹下面新建request.json
 引入axios,新建axios.导出request
 const request = axios.create({
  baseURL: 'http://ttapi.research.itcast.cn/' // 基础路径
})
export default request
 
 登入页面布局
	ps使用不熟练，改用蓝湖操作
	在ps中打开设计稿，选用蓝湖插件上传设计稿，在网页端查看。所以像素的除以2位实际值
	页面布局，配合蓝湖， 效果图，实际图一起来操作。主要是用到vant组件后，组件里面的内容需要获取类名字
	
	头部样式在多个页面都会用到，直接把样式写到index.less中，取名app-nav-bar，在用到这个样式的时候，给类名它
	Button里面放字体图标icon-prefix 
	如果修改样式后不生效，可能是选择类名后级别不够可以在样式后面加  !important
	另外一种方法，全局样式覆盖vant的样式，可以在main.js中最后倒入全局样式，让vant样式在前面，全局样式在后面
	
登入页面 功能基本实现
	给登录按钮注册点击事件。
	  // 1:找到数据接口(接口文档)
      // 2:封装请求方法
      // 3:请求调用登入
	  // 4:处理响应结果
	 
	 创建 src/api/user.js 模块，封装登录请求方法：
	 /**
 * 用户相关的请求模块
 */
import request from "@/utils/request"

/**
 * 用户登录
 */
export const login = data => {
  return request({
    method: 'POST',
    url: '/app/v1_0/authorizations',
    data
  })
}
登录处理函数如下

默认号码：
17090086870
246810
import { login } from '@/api/user'

async onLogin () {
  try {
    const res = await login(this.user)
    console.log('登录成功', res)
  } catch (err) {
    if (err.response.status === 400) {
      console.log('登录失败', err)
    }
  }
}
表单中数据双向绑定v-model this.user可以获取到数据，作为参数传递到登入请求中
使用async await  promise的语法糖处理，省去回调函数

登入提示效果（Toast）
需要单独加载import { Toast } from 'vant'
duration: 0  参数为0表示一直不消失
如果不import Toast  可以使用this.$toast

表单提交效果实现
使用 Field 的 rules 属性定义校验规则。
最好不要写在模板中，在data中定义一个属性formRules
	1：发送验证码，登入都是button点击都会导致submit提交  怎么处理
	2：提示消息都是标红在input下面输出  如何改为toast
	
	form表单 show-error show-error-message都设置为false，增加failed事件，van-field添加name属性
	在failed事件中输出错误信息，并且把它位置放在上面
	onFailed (error) {
      if (error.errors[0]) {
        Toast({
          message: error.errors[0].message,
          position: 'top'
        })
      }
    }
	
验证码点击实现倒计时功能
	校验手机号码	验证通过-》发送请求-》用户接受验证码-》请求登入
	请求发送验证码-》隐藏发送按钮，显示倒计时按钮
	倒计时结束，隐藏倒计时，显示发送按钮
	
	验证表单（vaildate）支持name来验证表单，返回一个promise对象，直接使用async await
	点击发送验证码时候click加一个prevent阻止默认验证事件
		prevent为vue中事件修饰符
	通过 ref 可以获取到 Form 实例并调用实例方法
	在from中ref="login-from"
	async onSengSms () {
      try {
        await this.$refs['login-from'].validate('mobile')
      } catch (err) {
        // TODO handle the exception
        Toast({
          message: err.message,
          position: 'top'
        })
      }
    }
	
短信发送请求
export const sendSms = mobile => {
  return request({
    method: 'GET',
    url: `/app/v1_0/sms/codes/${mobile}`
  })
}  
es6拼接
eg:
http://ttapi.research.itcast.cn/app/v1_0/sms/codes/18271671850
{
    "message": "OK",
    "data": {
        "mobile": "18271671850"
    }
}

发送短信代码
const res = await sendSms(this.user.mobile)
因为所有err都会到catch中，为了不同错分别提升
需要判断错误是手机号错误，还是验证码发送太频繁，或者未知错误

async onSengSms () {
      try {
        await this.$refs['login-from'].validate('mobile')
        const res = await sendSms(this.user.mobile)
        console.log(res)
      } catch (err) {
        // TODO handle the exception
        let message = ''
        if (err && err.response && err.response.status === 429) {
          message = '发送太频繁,请稍后在发送'
        } else if (err.name === 'mobile') {
          message = err.message
        } else {
          // 未知错误
          message = '发送失败!请重试'
        }
        Toast({
          message,
          position: 'top'
        })
      }
    }
	
	倒计时
	<van-count-down v-if="isCountDownShow"
        :time="1000 * 6"
        format="ss s"
        @finish="isCountDownShow = false"/>
		组件  v-if v-else显示   finish事件倒计时结束触发
		
		
	发送请求时候，需要页面按钮禁用，不要重复触发事件发请求
	增加loading,默认为false,点击发送验证码按钮后为true，请求结束该为false.不管请求是否成功
	
	
	本地存储的数据不是响应式的，用户存储 Token  Vuex容器（获取方便，响应式）
	对象不能直接存在本地存储，需要JSON.stringify转成字符串在存储
	
	1：封装本地存储（setItem,getItem,removeItem）
	2:vueX 状态管理登入的用户
	导入setItem,getItem import { getItem, setItem } from '@/utils/storage'
	为了区别，方便阅读，设置const常量USER_KEY
	state里面先在本地存储里面读取到数据
	mutations里面设置state的值，用到函数setUser
	setUser (state, data) {
      state.user = data
    }
	在登入成功时候，使用commit调用setUser来修改state的值
	// 将后端返回的用户登录状态（token等数据）放到 Vuex 容器中
    this.$store.commit('setUser', data.data)
	
	设置成功后，放在页面刷新数据丢失，把数据存储在本地存储setItem(USER_KEY, state.user)
	
	
我的模块
	1：页面布局，配合蓝湖
	van-cell-group单元格布局(van-cell-group)
	van-cell插槽自定义布局，van-image  ,div ,van-button分别放左边图片，昵称，右侧按钮  
	
	Grid 宫格布局放数据信息（van-grid）
	van-grid-item一样使用插槽放内容（van-grid-item）
	div为solt里面放数量和名字
	
	收藏，历史使用Grid 宫格布局（设置:column-num="2"，一列放2个）
	van-cell设置页面导航<van-cell title="路由跳转" is-link to="index" />
	
	样式设置
	登入或者没有登入显示不一样的页面。v-if  v-else判断
	把vuex里面的数据通过mapState映射到页面中使用
	import { mapState } from 'vuex'
	computed: {
    ...mapState(['user'])
  }
  这样就可以在页面中使用user来获取到状态管理里面的数据
	在未登入页面，给手机图片的div给点击事件。点击跳转到login页面
	@click=$router.push('/login')

	登入界面，登入成功后，返回到之前页面。直接用this.$router.back()跳转
	
	2：实现退出功能
	使用vant组件dailog
	
	
显示当前登入用户信息
http://ttapi.research.itcast.cn/app/v1_0/user
获取用户自己信息
	1：封装请求方法getUserInfo 
		需要加header，里面放Authorization
		把store引入到api的user.js中。通过store.state.user.token获取到
		然后用es6字符串拼接
	2：create中调用loadCurrentUser,在 method中实现
		ayncs  await  把结果赋值给data中的currentUser，在页面渲染。判断数据是否合理
		
	3：通过拦截器来请求。这样做后不需要在请求中添加headers了。
		axios的拦截器方法interceptors（github中查找）
		axios.interceptors.request.use(function (config) {
			// Do something before request is sent
			return config;
		  }, function (error) {
			// Do something with request error
			return Promise.reject(error);
		  });
		  
		  本项目中因为axios是const request = axios.create的。所以使用拦截器时候需要使用request
	
	
首页
	1：顶栏实现
	全局样式 app-nav-bar需要修改下不然不能把button放上去
	
	2：文章频道列表 van-tabs
		通过 v-model:active 绑定当前激活标签对应的索引值，默认情况下启用第一个标签。
		
		展示频道列表，active里面加载函数。请求数据 在api里面封装获取频道列表函数
		
	3：文章列表封装 van-list
		每一个频道都对应一个文章列表，不可能对每一个频道都写一个请求。所以需要搞一个文章列表组件
		让组件里面带参数，把文字频道的id等信息传进去。props
		props: {
			channel: {
			type: Object,
			required: true
			}
		}
		vant  的tab有一个功能就是，没有点击的组件先不展示，只有点击后才会展示
		
		在home文件夹下面新建一个components文件夹，里面新建article-list.vue
		把这个组件在，home中引入，注册，使用
		
		vant  list组件引入,查看官方文档使用  
		修改list样式，让在页面中间滚动
		.article-list{
			position:fixed;
			left:0;
			right:0;
			top:90px;
			bottom:50px;
			overflow-y:auto;
		}
		
		文章列表数据获取，api里面封装请求（新建article.js）
		export const getArticles = (params) => {
		  return request({
			method: 'GET',
			url: '/app/v1_1/articles',
			params
		  })
		}
		params参数，分别为频道id  时间戳（注意，Date.now()或者this.timestamp）
		获取文章信息
		1. 请求获取数据 2. 把数据放到 list 数组中 3. 设置本次加载状态结束，它才可以判断是否需要加载下一次，否则就会永远的停在这里
		4. 判断数据是否全部加载完成，没有加载完成，则设置timestamp
		
		下拉刷新,vant组件success-duration，success-text，@refresh="onRefresh" v-model="isRefreshLoading"
		在下拉后，会默认把v-model="isRefreshLoading"里面值改为ture
		所以在下拉获取数据后，需要手动关闭刷新状态
		
		封装文章列表项组件
			创建 src/components/article-item/index.vue 组件
			样式布局van-cell  插槽使用，需要判断是一张封面图还是三张封面图
			在文章列表组建中使用文章列表项组件，把article作为参数传递。在子组件总props拿到
			
		处理图片渲染403错误，referrer。在public的html中添加<meta name="referrer" content="no-referrer" />
		不发送referrer,让后端服务器以为是自己人发送请求
		
		home页面tabbar样式调整
			加边框，修改active后颜色位置  /deep/
			
文章频道列表
	1：弹出层实现（Popub组件）
		挂载在body上面，样式设置在home-container上无效。要么设置全局，要么行内样式
		v-model绑定是否显示 closeable关闭按钮
	2：汉堡按钮实现
		在van-tabs后面放一个图标，通过点击显示弹出层
		使用插槽放一个按钮在最后面，绝对定位放在最右边。
		在最后面放一个一样大的空间，里面为空。占位置 设置样式时候直接给宽度无效，因为父容器flex布局
		已经把整个区域分割完了  用flex-shrink=0
	3：弹出层组件
	4：数据展示
		我的频道和，首页的频道是一样的，可以通过props传值获取
		遍历props里面的值
		展示推荐频道  用所有的频道减去我的频道获取
		在计算属性里面获取值，遍历计算属性
		  computed: {
    // 推荐频道
    recommendChannels () {
		  const arr = []
		  for (let i = 0; i < this.allChannels.length; i++) {
			for (let j = 1; j < this.userChannels.length; j++) {
			  var flag = false
			  if (this.allChannels[i].id === this.userChannels[j].id) {
				flag = true
				break
			  }
			}
			if (!flag) {
			  arr.push(this.allChannels[i])
			}
		  }
		  console.log(arr, '123')
		  return arr
		}
	  }
	  
	   <van-grid :gutter="6">
		  <van-grid-item
			class='grid-item'
			v-for="(channel,index) in recommendChannels"
			:key="index"
			:text="channel.name"
		  ></van-grid-item>
		</van-grid>
		
	添加频道
	给所有推荐频道增加点击事件，点击后增加到我的频道
	因为是计算属性计算的值，所以值改变会导致重新计算
	
	编辑频道，点击后出现删除图标
	bool值来控制删除图标是否显示  点击后，文字会往下压。把margin-top设置为0
	
	实现删除频道和进去对应页面功能
	
	
	点击切换进入对应页面
	子传父事件，一个事件为关闭弹出页面，一个事件为跳转到对应页面
	this.$emit('update-active', index)  把索引传过去
    this.$emit('close')
	在父组件中监听这两个事件
	
	<channel-edit :user-channels='channels'
      @close="isChannelEditShow = false"
      @update-active="onUpdatActive"
      ></channel-edit>
	  
	  onUpdatActive (index) {
      this.active = index
    }
	
	在频道页面中也高亮显示首页被选中的频道
	
	数据持久化
	1：登入用户
	2：没有登入用户
	
	没有登入的用户，把频道放在本地存储中。开始获取默认的推荐频道
	登入的用户，把频道存在远端服务器
	
	进入app,先判断用户是否登入，登入的用户获取自己的频道列表（换设备也有效）
	没有登入的用户，先看本地存储里面是否有频道，有就取，没有就获取默认的频道
	
文章搜索模块
 组件创建，配置路由（一级路由）
 home页面search  btn点击后路由跳转 使用vant 中btn的 to 属性
 
	首页页面布局
	搜索栏
	<van-search 
		v-model="value"
		disabled placeholder="请输入搜索关键词"
		show-action
		@search="onSearch"
		@cancel="onCancel"
	/>
	在search外层包裹from标签且 action 不为空，即可在 iOS /Android输入法中显示搜索按钮。
	
	联系建议，历史结果，搜索结果  封装为组件，方便维护
	van-cell  list组件使用
	
	三个组件显示
	默认显示搜索历史，搜索框有类容 显示联想建议。触发搜索功能显示搜索结果
	
	v-if  v-if-else  v-else判断显示拿一个组件  v-if需要放在最前面
	搜索框获得焦点时候，要关闭显示结果  改成联想建议
	
	业务功能实现
		搜索建议，根据搜索框内容发送请求
		把搜索框的数据专传递给联想建议组件
		props传值
		watch 监听props传递过来的值
		第一次输入时候，没有被监视到。因为组件只有被渲染出来后，才会被监视。第一次输入的时候，组件没有被渲染出来
		需要让开始就被触发一次  添加一个handel() {} 完整写法
		watchd 完整写法。vue官方文档
		
		拿到数据，发请求，数据绑定模板响应
		
		防抖函数  优化联想数据请求
		第三方包引入
	联想结果 高亮显示
	v-html  正则表达式忽略大小写
	
	props数据不能重新赋值 =
	想要修改，父组件自己修改
	
	
	跨域 不同源策略  防止数据被盗用  cookie  localstroige  indexDB
	解决办法  JSONP跨域  只支持get
	croes  服务器完成，客户端不用管
	服务器代理  相当于客户端向中间服务器发送请求（此时同源） 中间服务器在向接口服务器发送请求  返回数据给中间服务器，中间服务器把数据给客户端
	
	vue中怎么解决   vue.config.js中设置
	
文章详情模块
	views下面创建article目录 index.vue  配置路由  动态路由
	在这个页面需要获取文章ID，在文章列表项组件中，点击跳转到文章详情页面 
	to属性
	:to="{
      name: 'article',
      params: {
        articleId: article.art_id
      }
    }"
	在路由中配置props：true
	在文章详情页面的props里面接受参数
	articleId: {
      type: [Number, String, Object],
      required: true
    }
	后续就可以通过this.articleId来判断是哪一篇文章了
	
	页面布局
	导入github-markdown.css  github中下载  文章正文类容样式